\relax 
\providecommand\hyper@newdestlabel[2]{}
\@writefile{toc}{\contentsline {chapter}{\numberline {1}Signal Processing with GPUs}{1}{chapter.1}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{sec:gpu}{{1}{1}{Signal Processing with GPUs}{chapter.1}{}}
\@writefile{toc}{\contentsline {subsubsection}{Frame Synchronization}{1}{section*.7}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.1}{\ignorespaces The iNET packet structure.}}{1}{figure.1.1}}
\newlabel{fig:packet}{{1.1}{1}{Frame Synchronization}{figure.1.1}{}}
\newlabel{eq:gpu-L-4}{{1.1}{2}{Frame Synchronization}{equation.1.0.1}{}}
\newlabel{eq:gpu-L-pedone-geoghegan-2}{{1.2}{2}{Frame Synchronization}{equation.1.0.2}{}}
\newlabel{eq:gpu-L-pedone-geoghegan-3}{{1.3}{2}{Frame Synchronization}{equation.1.0.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.2}{\ignorespaces The block diagram for the frame synchronization implementation.}}{3}{figure.1.2}}
\newlabel{fig:preambleBlock}{{1.2}{3}{Frame Synchronization}{figure.1.2}{}}
\newlabel{eq:gpu-L-pedone-geoghegan-4}{{1.4}{3}{Frame Synchronization}{equation.1.0.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.3}{\ignorespaces The output of the Preamble Detector $L(u)$.}}{4}{figure.1.3}}
\newlabel{fig:L_2_packets}{{1.3}{4}{Frame Synchronization}{figure.1.3}{}}
\newlabel{eq:preamble_det_i_hat}{{1.5}{5}{Frame Synchronization}{equation.1.0.5}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.4}{\ignorespaces Detailed view of $L(u)$. (a): correlation peaks of a distortion free and noiseless signal; (b): correlation peaks of a distortion free but noisy signal with $E_b/N_0 = 0$dB; (c): correlation peaks of a distorted and noisy signal with $E_b/N_0 = 0$dB; (d): correlation peaks of a distorted and noisy signal with $E_b/N_0 = 0$dB}}{6}{figure.1.4}}
\newlabel{fig:L_corr_creepy}{{1.4}{6}{Frame Synchronization}{figure.1.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.5}{\ignorespaces Safe search windows defined to search only one preamble correlation peak.}}{7}{figure.1.5}}
\newlabel{fig:L_windows}{{1.5}{7}{Frame Synchronization}{figure.1.5}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.6}{\ignorespaces The starting sample index for each packet in the batch.}}{8}{figure.1.6}}
\newlabel{fig:packets_in_batch}{{1.6}{8}{Frame Synchronization}{figure.1.6}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.7}{\ignorespaces The packetized structure of the received signals after the frame synchronization step.}}{8}{figure.1.7}}
\newlabel{fig:packetized}{{1.7}{8}{Frame Synchronization}{figure.1.7}{}}
\citation{nvidia-CUDAdoc:2015}
\@writefile{toc}{\contentsline {subsubsection}{Frequency Offset Compensation}{9}{section*.8}}
\newlabel{sec:jeffs_frequencyoffsetestimator}{{1}{9}{Frequency Offset Compensation}{section*.8}{}}
\newlabel{eq:jeff-ML-w-final3}{{1.7}{9}{Frequency Offset Compensation}{equation.1.0.7}{}}
\newlabel{eq:jeff-ML-w-final3_reformed}{{1.8}{9}{Frequency Offset Compensation}{equation.1.0.8}{}}
\newlabel{eq:freq_offset_r1}{{1.9}{9}{Frequency Offset Compensation}{equation.1.0.9}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.8}{\ignorespaces The block diagram for the Frequency Offset estimator and sample rotation implementation.}}{10}{figure.1.8}}
\newlabel{fig:frequencyOffsetBlock}{{1.8}{10}{Frequency Offset Compensation}{figure.1.8}{}}
\@writefile{brf}{\backcite{nvidia-CUDAdoc:2015}{{10}{1}{equation.1.0.10}}}
\newlabel{eq:jeff-Omega_0-matrix1}{{1.11}{10}{Frequency Offset Compensation}{equation.1.0.11}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.9}{\ignorespaces The block diagram for the Channel estimator.}}{11}{figure.1.9}}
\newlabel{fig:channelBlock}{{1.9}{11}{Channel Estimation}{figure.1.9}{}}
\@writefile{toc}{\contentsline {subsubsection}{Channel Estimation}{11}{section*.9}}
\newlabel{eq:jeff-ML-h-final2}{{1.13}{11}{Channel Estimation}{equation.1.0.13}{}}
\newlabel{eq:channel_reformed_no_freq}{{1.14}{11}{Channel Estimation}{equation.1.0.14}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.10}{\ignorespaces The block diagram for the Noise Variance estimator.}}{12}{figure.1.10}}
\newlabel{fig:noiseBlock}{{1.10}{12}{Noise Variance Estimation}{figure.1.10}{}}
\newlabel{eq:channel_reformed_final}{{1.16}{12}{Channel Estimation}{equation.1.0.16}{}}
\@writefile{toc}{\contentsline {subsubsection}{Noise Variance Estimation}{12}{section*.10}}
\newlabel{eq:jeff-ML-s2-final3}{{1.17}{12}{Noise Variance Estimation}{equation.1.0.17}{}}
\newlabel{eq:noise_var_reformed}{{1.19}{13}{Noise Variance Estimation}{equation.1.0.19}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.0.1}Equalizer GPU Implementation}{13}{subsection.1.0.1}}
\@writefile{toc}{\contentsline {subsubsection}{Zero-Forcing Equalizer}{13}{section*.11}}
\newlabel{eq:jeff-spike-solution}{{1.21}{13}{Zero-Forcing Equalizer}{equation.1.0.21}{}}
\newlabel{eq:jeff-zf-H-matrix}{{1.22}{14}{Zero-Forcing Equalizer}{equation.1.0.22}{}}
\newlabel{eq:jeff-cu-vector-def}{{1.23}{14}{Zero-Forcing Equalizer}{equation.1.0.23}{}}
\newlabel{eq:hhh}{{1.24}{14}{Zero-Forcing Equalizer}{equation.1.0.24}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.11}{\ignorespaces The block diagram for the Zero Forcing equalizer implementation.}}{15}{figure.1.11}}
\newlabel{fig:ZFblock}{{1.11}{15}{Zero-Forcing Equalizer}{figure.1.11}{}}
\newlabel{eq:hun0-vector-def}{{1.26}{15}{Zero-Forcing Equalizer}{equation.1.0.26}{}}
\newlabel{eq:jeff-spike-solution-reformed}{{1.27}{16}{Zero-Forcing Equalizer}{equation.1.0.27}{}}
\newlabel{eq:jeff-spike-solution-reformed_vectors}{{1.28}{16}{Zero-Forcing Equalizer}{equation.1.0.28}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.12}{\ignorespaces The block diagram for the MMSE equalizer implementation.}}{17}{figure.1.12}}
\newlabel{fig:MMSEblock}{{1.12}{17}{MMSE Equalizer}{figure.1.12}{}}
\@writefile{toc}{\contentsline {subsubsection}{MMSE Equalizer}{17}{section*.12}}
\newlabel{eq:jeff-copt-Ri}{{1.29}{17}{MMSE Equalizer}{equation.1.0.29}{}}
\newlabel{eq:jeff-ZF-vectors}{{1.33}{18}{MMSE Equalizer}{equation.1.0.33}{}}
\@writefile{toc}{\contentsline {subsubsection}{CMA Equalizer}{18}{section*.13}}
\newlabel{eq:jeff-DelJcma-approx}{{1.34}{18}{CMA Equalizer}{equation.1.0.34}{}}
\newlabel{eq:jeff-cma-update-summary}{{1.35}{18}{CMA Equalizer}{equation.1.0.35}{}}
\newlabel{eq:jeff-DelJcma-approx}{{1.36}{18}{CMA Equalizer}{equation.1.0.36}{}}
\newlabel{eq:jeff-cma-update-summary}{{1.37}{18}{CMA Equalizer}{equation.1.0.37}{}}
\newlabel{eq:toy-delj}{{1.40}{19}{CMA Equalizer}{equation.1.0.40}{}}
\newlabel{eq:toy-conv}{{1.41}{19}{CMA Equalizer}{equation.1.0.41}{}}
\newlabel{eq:y_portion}{{1.42}{21}{CMA Equalizer}{equation.1.0.42}{}}
\newlabel{eq:y_reverse}{{1.43}{21}{CMA Equalizer}{equation.1.0.43}{}}
\@writefile{toc}{\contentsline {subsubsection}{Frequency Domain Equalizer 1}{21}{section*.14}}
\newlabel{eq:FDE1}{{1.44}{21}{Frequency Domain Equalizer 1}{equation.1.0.44}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.13}{\ignorespaces The computation of $\nabla \mathbf  {J}$ can be done with a convolution of directly.}}{22}{figure.1.13}}
\newlabel{fig:delJ_convORsum}{{1.13}{22}{CMA Equalizer}{figure.1.13}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.14}{\ignorespaces The block diagram showing how the GPU implements the CMA algorithm.}}{22}{figure.1.14}}
\newlabel{fig:CMA_block}{{1.14}{22}{CMA Equalizer}{figure.1.14}{}}
\citation{NO_perrins}
\@writefile{lof}{\contentsline {figure}{\numberline {1.15}{\ignorespaces The block diagram showing how the GPU calculates the $\text  {FDE}_1$ equalizer.}}{23}{figure.1.15}}
\newlabel{fig:FDE1_block}{{1.15}{23}{Frequency Domain Equalizer 1}{figure.1.15}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.16}{\ignorespaces The block diagram showing how the GPU calculates the $\text  {FDE}_2$ equalizer.}}{23}{figure.1.16}}
\newlabel{fig:FDE2_block}{{1.16}{23}{Frequency Domain Equalizer 2}{figure.1.16}{}}
\@writefile{toc}{\contentsline {subsubsection}{Frequency Domain Equalizer 2}{23}{section*.15}}
\newlabel{eq:FDE2}{{1.45}{23}{Frequency Domain Equalizer 2}{equation.1.0.45}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.17}{\ignorespaces The block diagram showing how the GPU applies an FIR equlizer and the Numerically Optimized Perrins detection filter.}}{24}{figure.1.17}}
\newlabel{fig:apply_FIR_equalizer}{{1.17}{24}{FIR Equalizer Application}{figure.1.17}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.0.2}Filter Application GPU Implementation}{24}{subsection.1.0.2}}
\@writefile{brf}{\backcite{NO_perrins}{{24}{1.0.2}{subsection.1.0.2}}}
\@writefile{toc}{\contentsline {subsubsection}{FIR Equalizer Application}{24}{section*.16}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.18}{\ignorespaces The block diagram showing how the GPU applies $\text  {FDE}_1$ and the Numerically Optimized Perrins detection filter.}}{25}{figure.1.18}}
\newlabel{fig:apply_FDE1}{{1.18}{25}{Frequency Domain Equalizer Application}{figure.1.18}{}}
\@writefile{toc}{\contentsline {subsubsection}{Frequency Domain Equalizer Application}{25}{section*.17}}
\newlabel{eq:apply_FDE1}{{1.46}{25}{Frequency Domain Equalizer Application}{equation.1.0.46}{}}
\newlabel{eq:apply_FDE2}{{1.47}{25}{Frequency Domain Equalizer Application}{equation.1.0.47}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.19}{\ignorespaces The block diagram showing how the GPU applies $\text  {FDE}_2$ with $\mathbf  {\Psi }$ and the Numerically Optimized Perrins detection filter.}}{26}{figure.1.19}}
\newlabel{fig:apply_FDE2}{{1.19}{26}{Frequency Domain Equalizer Application}{figure.1.19}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.0.3}GPU OQPSK Demodulator Implementation}{27}{subsection.1.0.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.20}{\ignorespaces The block diagram showing how the GPU applies the demodulator to equalized received samples to obtain the bit decisions.}}{28}{figure.1.20}}
\newlabel{fig:demod_block}{{1.20}{28}{GPU OQPSK Demodulator Implementation}{figure.1.20}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.21}{\ignorespaces The block diagram showing the OQPSK demodulator from Figure \ref  {fig:demod_block}. The $\mathaccentV {hat}05E{a}(k)$ is data-aided for $k<L_p+L_{asm}$ and decision directed when $k\geq L_p+L_{asm}$.}}{28}{figure.1.21}}
\newlabel{fig:demod_loop}{{1.21}{28}{GPU OQPSK Demodulator Implementation}{figure.1.21}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.22}{\ignorespaces The bit stream vector $\mathaccentV {hat}05E{\mathbf  {s}}_{FPGA}$ is array chars. The bit streams are interleaved and each char contains 8 bit decisions from a single bit stream.}}{29}{figure.1.22}}
\newlabel{fig:bit_inter}{{1.22}{29}{GPU OQPSK Demodulator Implementation}{figure.1.22}{}}
\@setckpt{gpu}{
\setcounter{page}{30}
\setcounter{equation}{49}
\setcounter{enumi}{0}
\setcounter{enumii}{0}
\setcounter{enumiii}{0}
\setcounter{enumiv}{0}
\setcounter{footnote}{0}
\setcounter{mpfootnote}{0}
\setcounter{part}{0}
\setcounter{chapter}{1}
\setcounter{section}{0}
\setcounter{subsection}{3}
\setcounter{subsubsection}{0}
\setcounter{paragraph}{0}
\setcounter{subparagraph}{0}
\setcounter{figure}{22}
\setcounter{table}{0}
\setcounter{parentequation}{0}
\setcounter{cp@cnt}{0}
\setcounter{cp@tempcnt}{0}
\setcounter{subfigure}{0}
\setcounter{lofdepth}{1}
\setcounter{subtable}{0}
\setcounter{lotdepth}{1}
\setcounter{Item}{0}
\setcounter{Hfootnote}{0}
\setcounter{bookmark@seq@number}{9}
\setcounter{section@level}{1}
}
