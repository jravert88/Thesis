\relax 
\providecommand\hyper@newdestlabel[2]{}
\@writefile{toc}{\contentsline {chapter}{\numberline {4}Equalizer GPU Implementation and Bit Error Rate Performance}{65}{chapter.4}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\newlabel{chap:equalizers_in_gpus}{{4}{65}{Equalizer GPU Implementation and Bit Error Rate Performance}{chapter.4}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.1}GPU Implementation}{65}{section.4.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.1}{\ignorespaces A block diagram representation of $\mathbf  {y} = \mathbf  {x} * \mathbf  {c}$. Convolution is performed in the frequency domain. All the required operations in the top part of the figure are represented by the block in the lower part of the figure.}}{66}{figure.4.1}}
\newlabel{fig:Conv2}{{4.1}{66}{GPU Implementation}{figure.4.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.2}{\ignorespaces A block diagram representation of $\mathbf  {y} = (\mathbf  {x} * \mathbf  {c} ) * \mathbf  {D}$ (cascaded convolution), where $\mathbf  {D}$ is the FFT of a filter that does not change with the data (i.e. $\mathbf  {D}$ is precomputed and stored. Convolution is performed in the frequency domain. All the required operations in the top part of the figure are represented by the block in the lower part of the figure.}}{66}{figure.4.2}}
\newlabel{fig:Conv3}{{4.2}{66}{GPU Implementation}{figure.4.2}{}}
\citation{hayes:1996}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1.1}Zero-forcing and MMSE GPU Implementation}{67}{subsection.4.1.1}}
\newlabel{eq:R_h_ref}{{4.1}{67}{Zero-forcing and MMSE GPU Implementation}{equation.4.1.1}{}}
\@writefile{brf}{\backcite{hayes:1996}{{67}{4.1.1}{equation.4.1.1}}}
\citation{wiki:Sparse_matrix}
\citation{CUDA_toolkit_doc}
\@writefile{lof}{\contentsline {figure}{\numberline {4.3}{\ignorespaces Block diagram showing how the zero-forcing equalizer coefficients are implemented in the GPU.}}{68}{figure.4.3}}
\newlabel{fig:blockZF}{{4.3}{68}{Zero-forcing and MMSE GPU Implementation}{figure.4.3}{}}
\@writefile{brf}{\backcite{wiki:Sparse_matrix}{{68}{4.1.1}{equation.4.1.1}}}
\@writefile{brf}{\backcite{CUDA_toolkit_doc}{{68}{4.1.1}{equation.4.1.1}}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.4}{\ignorespaces Block diagram showing how the minimum mean-squared error equalizer coefficients are implemented in the GPU.}}{69}{figure.4.4}}
\newlabel{fig:blockMMSE}{{4.4}{69}{Zero-forcing and MMSE GPU Implementation}{figure.4.4}{}}
\@writefile{lot}{\contentsline {table}{\numberline {4.1}{\ignorespaces Algorithms used to compute the ZF and MMSE equalizer filters.}}{69}{table.4.1}}
\newlabel{tab:ZFMMSEtimingComparison}{{4.1}{69}{Zero-forcing and MMSE GPU Implementation}{table.4.1}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1.2}Constant Modulus Algorithm GPU Implementation}{69}{subsection.4.1.2}}
\newlabel{eq:DelJcma-approxr_ref}{{4.2}{69}{Constant Modulus Algorithm GPU Implementation}{equation.4.1.2}{}}
\newlabel{eq:CMA_challenge_ref}{{4.3}{70}{Constant Modulus Algorithm GPU Implementation}{equation.4.1.3}{}}
\newlabel{eq:delJ_writeoutr}{{4.5}{70}{Constant Modulus Algorithm GPU Implementation}{equation.4.1.5}{}}
\newlabel{eq:delJ_direct_way}{{4.6}{70}{Constant Modulus Algorithm GPU Implementation}{equation.4.1.6}{}}
\newlabel{eq:CMA_delJ_rice_reformed}{{4.8}{71}{Constant Modulus Algorithm GPU Implementation}{equation.4.1.8}{}}
\newlabel{eq:CMA_conv_z_rho}{{4.9}{71}{Constant Modulus Algorithm GPU Implementation}{equation.4.1.9}{}}
\newlabel{eq:CMA_delJ_donzo}{{4.10}{71}{Constant Modulus Algorithm GPU Implementation}{equation.4.1.10}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.5}{\ignorespaces Diagram showing the relationships between $z(n)$, $\rho (n)$ and $\gamma (n)$.}}{72}{figure.4.5}}
\newlabel{fig:convolutionFigureRice}{{4.5}{72}{Constant Modulus Algorithm GPU Implementation}{figure.4.5}{}}
\@writefile{lot}{\contentsline {table}{\numberline {4.2}{\ignorespaces MATLAB code listing for the CMA equalizer.}}{72}{table.4.2}}
\newlabel{code:CMA}{{4.2}{72}{Constant Modulus Algorithm GPU Implementation}{table.4.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.6}{\ignorespaces Block diagram showing how the CMA equalizer filter is implemented in the GPU using frequency-domain convolution twice per iteration.}}{73}{figure.4.6}}
\newlabel{fig:blockCMA}{{4.6}{73}{Constant Modulus Algorithm GPU Implementation}{figure.4.6}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.7}{\ignorespaces After the final CMA iteration, the de-rotated samples are filtered by the detection filter and the CMA equalizer in the frequency domain.}}{73}{figure.4.7}}
\newlabel{fig:blockCMA_apply}{{4.7}{73}{Constant Modulus Algorithm GPU Implementation}{figure.4.7}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1.3}Frequency Domain Equalizer GPU Implementations}{73}{subsection.4.1.3}}
\@writefile{lot}{\contentsline {table}{\numberline {4.3}{\ignorespaces Algorithms used to compute the cost function gradient $\nabla J$.}}{73}{table.4.3}}
\newlabel{tab:CMAtimingComparison}{{4.3}{73}{Constant Modulus Algorithm GPU Implementation}{table.4.3}{}}
\@writefile{lot}{\contentsline {table}{\numberline {4.4}{\ignorespaces Execution times for calculating and applying Frequency Domain Equalizer One and Two.}}{74}{table.4.4}}
\newlabel{tab:FDEtimingComparison}{{4.4}{74}{Frequency Domain Equalizer GPU Implementations}{table.4.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.8}{\ignorespaces Block diagram showing frequency domain equalizer one is implemented in the frequency domain in GPUs.}}{74}{figure.4.8}}
\newlabel{fig:blockFDE1}{{4.8}{74}{Frequency Domain Equalizer GPU Implementations}{figure.4.8}{}}
\newlabel{eq:non-overwordative1}{{4.11}{74}{Frequency Domain Equalizer GPU Implementations}{equation.4.1.11}{}}
\newlabel{eq:non-overwordative2}{{4.12}{74}{Frequency Domain Equalizer GPU Implementations}{equation.4.1.12}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.9}{\ignorespaces Block diagram showing frequency domain equalizer two is implemented in the frequency domain in GPUs.}}{75}{figure.4.9}}
\newlabel{fig:blockFDE2}{{4.9}{75}{Frequency Domain Equalizer GPU Implementations}{figure.4.9}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.2}CPU and GPU Pipelining}{75}{section.4.2}}
\newlabel{RF2}{76}
\@writefile{lof}{\contentsline {figure}{\numberline {4.10}{\ignorespaces Block diagram showing how the CPU and three GPUs are pipelined.}}{76}{figure.4.10}}
\newlabel{fig:GPUpipeLines}{{4.10}{76}{CPU and GPU Pipelining}{figure.4.10}{}}
\@writefile{lot}{\contentsline {table}{\numberline {4.5}{\ignorespaces Execution times for blocks in Figure \ref  {fig:GPUpipeLines} in order as they appear left to right then top to bottom.}}{77}{table.4.5}}
\newlabel{tab:pipelineExecutionTimes}{{4.5}{77}{CPU and GPU Pipelining}{table.4.5}{}}
\citation{rice-davis-bettwieser:2004}
\citation{hog2016}
\@writefile{toc}{\contentsline {section}{\numberline {4.3}Laboratory Test Results}{78}{section.4.3}}
\@writefile{brf}{\backcite{rice-davis-bettwieser:2004}{{78}{4.3}{figure.4.11}}}
\@writefile{brf}{\backcite{hog2016}{{78}{4.3}{figure.4.11}}}
\newlabel{RF3}{79}
\@writefile{lof}{\contentsline {figure}{\numberline {4.11}{\ignorespaces Block diagram showing the configuration for static multipath tests to compare the five data-aided equalizers to no equalization.}}{79}{figure.4.11}}
\newlabel{fig:LabTestBlock}{{4.11}{79}{Laboratory Test Results}{figure.4.11}{}}
\newlabel{RF4}{80}
\@writefile{lof}{\contentsline {figure}{\numberline {4.12}{\ignorespaces Channel 1 BER static lab test: (top) parameters for the three ray channel; (bottom left) a screen capture of the spectrum with averaging enabled; (bottom right) BER curve of the five data-aided equalizers and no equalization.}}{80}{figure.4.12}}
\newlabel{fig:BER1}{{4.12}{80}{Laboratory Test Results}{figure.4.12}{}}
\newlabel{RF5}{81}
\@writefile{lof}{\contentsline {figure}{\numberline {4.13}{\ignorespaces Channel 2 BER static lab test: (top) parameters for the three ray channel; (bottom left) a screen capture of the spectrum with averaging enabled; (bottom right) BER curve of the five data-aided equalizers and no equalization. No points are shown for no equalization at some values of $E_b/N_0$ because the demodulator was unable to lock.}}{81}{figure.4.13}}
\newlabel{fig:BER2}{{4.13}{81}{Laboratory Test Results}{figure.4.13}{}}
\newlabel{RF6}{82}
\@writefile{lof}{\contentsline {figure}{\numberline {4.14}{\ignorespaces Channel 3 BER static lab test: (top) parameters for the three ray channel; (bottom left) a screen capture of the spectrum with averaging enabled; (bottom right) BER curve of the five data-aided equalizers and no equalization. No points are shown for no equalization because the demodulator was unable to lock.}}{82}{figure.4.14}}
\newlabel{fig:BER3}{{4.14}{82}{Laboratory Test Results}{figure.4.14}{}}
\@setckpt{equalizer_implementation_performance}{
\setcounter{page}{83}
\setcounter{equation}{12}
\setcounter{enumi}{0}
\setcounter{enumii}{0}
\setcounter{enumiii}{0}
\setcounter{enumiv}{0}
\setcounter{footnote}{0}
\setcounter{mpfootnote}{0}
\setcounter{part}{0}
\setcounter{chapter}{4}
\setcounter{section}{3}
\setcounter{subsection}{0}
\setcounter{subsubsection}{0}
\setcounter{paragraph}{0}
\setcounter{subparagraph}{0}
\setcounter{figure}{14}
\setcounter{table}{5}
\setcounter{parentequation}{0}
\setcounter{r@tfl@t}{6}
\setcounter{cp@cnt}{0}
\setcounter{cp@tempcnt}{0}
\setcounter{lstnumber}{270}
\setcounter{subfigure}{0}
\setcounter{lofdepth}{1}
\setcounter{subtable}{0}
\setcounter{lotdepth}{1}
\setcounter{Item}{0}
\setcounter{Hfootnote}{2}
\setcounter{bookmark@seq@number}{38}
\setcounter{lstlisting}{0}
\setcounter{section@level}{1}
}
